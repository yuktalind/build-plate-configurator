/**
 * Minified by jsDelivr using Terser v5.37.0.
 * Original file: /npm/three-bvh-csg@0.0.16/build/index.module.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{BufferAttribute,Vector3,Ray,Vector2,Vector4,Mesh,Matrix4,Line3,Plane,Triangle,DoubleSide,Matrix3,BufferGeometry,Group,Color,MeshPhongMaterial,MathUtils,LineSegments,LineBasicMaterial,InstancedMesh,SphereGeometry,MeshBasicMaterial}from"three";import{MeshBVH,ExtendedTriangle}from"three-mesh-bvh";const HASH_WIDTH=1e-6,HASH_HALF_WIDTH=5e-7,HASH_MULTIPLIER=Math.pow(10,-Math.log10(1e-6)),HASH_ADDITION=5e-7*HASH_MULTIPLIER;function hashNumber(t){return~~(t*HASH_MULTIPLIER+HASH_ADDITION)}function hashVertex2(t){return`${hashNumber(t.x)},${hashNumber(t.y)}`}function hashVertex3(t){return`${hashNumber(t.x)},${hashNumber(t.y)},${hashNumber(t.z)}`}function hashVertex4(t){return`${hashNumber(t.x)},${hashNumber(t.y)},${hashNumber(t.z)},${hashNumber(t.w)}`}function hashRay(t){return`${hashVertex3(t.origin)}-${hashVertex3(t.direction)}`}function toNormalizedRay(t,e,r){r.direction.subVectors(e,t).normalize();const n=t.dot(r.direction);return r.origin.copy(t).addScaledVector(r.direction,-n),r}function areSharedArrayBuffersSupported(){return"undefined"!=typeof SharedArrayBuffer}function convertToSharedArrayBuffer(t){if(t.buffer instanceof SharedArrayBuffer)return t;const e=t.constructor,r=t.buffer,n=new SharedArrayBuffer(r.byteLength),i=new Uint8Array(r);return new Uint8Array(n).set(i,0),new e(n)}function getIndexArray(t,e=ArrayBuffer){return t>65535?new Uint32Array(new e(4*t)):new Uint16Array(new e(2*t))}function ensureIndex(t,e){if(!t.index){const r=t.attributes.position.count,n=getIndexArray(r,e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer);t.setIndex(new BufferAttribute(n,1));for(let t=0;t<r;t++)n[t]=t}}function getVertexCount(t){return t.index?t.index.count:t.attributes.position.count}function getTriCount(t){return getVertexCount(t)/3}const DEGENERATE_EPSILON=1e-8,_tempVec=new Vector3;function toTriIndex(t){return~~(t/3)}function toEdgeIndex(t){return t%3}function sortEdgeFunc(t,e){return t.start-e.start}function getProjectedDistance(t,e){return _tempVec.subVectors(e,t.origin).dot(t.direction)}function hasOverlaps(t){for(let e=0,r=(t=[...t].sort(sortEdgeFunc)).length;e<r-1;e++){const r=t[e],n=t[e+1];if(n.start<r.end&&Math.abs(n.start-r.end)>1e-5)return!0}return!1}function getEdgeSetLength(t){let e=0;return t.forEach((({start:t,end:r})=>e+=r-t)),e}function matchEdges(t,e,r,n=1e-8){t.sort(sortEdgeFunc),e.sort(sortEdgeFunc);for(let n=0;n<t.length;n++){const i=t[n];for(let s=0;s<e.length;s++){const c=e[s];if(c.start>i.end);else{if(i.end<c.start||c.end<i.start)continue;if(i.start<=c.start&&i.end>=c.end)o(c.end,i.end)||t.splice(n+1,0,{start:c.end,end:i.end,index:i.index}),i.end=c.start,c.start=0,c.end=0;else if(i.start>=c.start&&i.end<=c.end)o(i.end,c.end)||e.splice(s+1,0,{start:i.end,end:c.end,index:c.index}),c.end=i.start,i.start=0,i.end=0;else if(i.start<=c.start&&i.end<=c.end){const t=i.end;i.end=c.start,c.start=t}else{if(!(i.start>=c.start&&i.end>=c.end))throw new Error;{const t=c.end;c.end=i.start,i.start=t}}}if(r.has(i.index)||r.set(i.index,[]),r.has(c.index)||r.set(c.index,[]),r.get(i.index).push(c.index),r.get(c.index).push(i.index),a(c)&&(e.splice(s,1),s--),a(i)){t.splice(n,1),n--;break}}}function i(t){for(let e=0;e<t.length;e++)a(t[e])&&(t.splice(e,1),e--)}function o(t,e){return Math.abs(e-t)<n}function a(t){return Math.abs(t.end-t.start)<n}i(t),i(e)}const DIST_EPSILON=1e-5,ANGLE_EPSILON=1e-4;class RaySet{constructor(){this._rays=[]}addRay(t){this._rays.push(t)}findClosestRay(t){const e=this._rays,r=t.clone();r.direction.multiplyScalar(-1);let n=1/0,i=null;for(let s=0,c=e.length;s<c;s++){const c=e[s];if(o(c,t)&&o(c,r))continue;const l=a(c,t),d=a(c,r),u=Math.min(l,d);u<n&&(n=u,i=c)}return i;function o(t,e){const r=t.origin.distanceTo(e.origin)>1e-5;return t.direction.angleTo(e.direction)>1e-4||r}function a(t,e){return t.origin.distanceTo(e.origin)/1e-5+t.direction.angleTo(e.direction)/1e-4}}}const _v0=new Vector3,_v1=new Vector3,_ray$2=new Ray;function computeDisjointEdges(t,e,r){const n=t.attributes,i=t.index,o=n.position,a=new Map,s=new Map,c=Array.from(e),l=new RaySet;for(let t=0,e=c.length;t<e;t++){const e=c[t],r=toTriIndex(e),n=toEdgeIndex(e);let a,d=3*r+n,u=3*r+(n+1)%3;i&&(d=i.getX(d),u=i.getX(u)),_v0.fromBufferAttribute(o,d),_v1.fromBufferAttribute(o,u),toNormalizedRay(_v0,_v1,_ray$2);let g=l.findClosestRay(_ray$2);null===g&&(g=_ray$2.clone(),l.addRay(g)),s.has(g)||s.set(g,{forward:[],reverse:[],ray:g}),a=s.get(g);let h=getProjectedDistance(g,_v0),p=getProjectedDistance(g,_v1);h>p&&([h,p]=[p,h]),_ray$2.direction.dot(g.direction)<0?a.reverse.push({start:h,end:p,index:e}):a.forward.push({start:h,end:p,index:e})}return s.forEach((({forward:t,reverse:e},n)=>{matchEdges(t,e,a,r),0===t.length&&0===e.length&&s.delete(n)})),{disjointConnectivityMap:a,fragmentMap:s}}const _vec2$1=new Vector2,_vec3$1=new Vector3,_vec4=new Vector4,_hashes=["","",""];class HalfEdgeMap{constructor(t=null){this.data=null,this.disjointConnections=null,this.unmatchedDisjointEdges=null,this.unmatchedEdges=-1,this.matchedEdges=-1,this.useDrawRange=!0,this.useAllAttributes=!1,this.matchDisjointEdges=!1,this.degenerateEpsilon=1e-8,t&&this.updateFrom(t)}getSiblingTriangleIndex(t,e){const r=this.data[3*t+e];return-1===r?-1:~~(r/3)}getSiblingEdgeIndex(t,e){const r=this.data[3*t+e];return-1===r?-1:r%3}getDisjointSiblingTriangleIndices(t,e){const r=3*t+e,n=this.disjointConnections.get(r);return n?n.map((t=>~~(t/3))):[]}getDisjointSiblingEdgeIndices(t,e){const r=3*t+e,n=this.disjointConnections.get(r);return n?n.map((t=>t%3)):[]}isFullyConnected(){return 0===this.unmatchedEdges}updateFrom(t){const{useAllAttributes:e,useDrawRange:r,matchDisjointEdges:n,degenerateEpsilon:i}=this,o=e?function(t){let e="";for(let r=0,n=c.length;r<n;r++){const n=s[c[r]];let i;switch(n.itemSize){case 1:i=hashNumber(n.getX(t));break;case 2:i=hashVertex2(_vec2$1.fromBufferAttribute(n,t));break;case 3:i=hashVertex3(_vec3$1.fromBufferAttribute(n,t));break;case 4:i=hashVertex4(_vec4.fromBufferAttribute(n,t))}""!==e&&(e+="|"),e+=i}return e}:function(t){return _vec3$1.fromBufferAttribute(d,t),hashVertex3(_vec3$1)},a=new Map,{attributes:s}=t,c=e?Object.keys(s):null,l=t.index,d=s.position;let u=getTriCount(t);const g=u;let h=0;r&&(h=t.drawRange.start,t.drawRange.count!==1/0&&(u=~~(t.drawRange.count/3)));let p=this.data;(!p||p.length<3*g)&&(p=new Int32Array(3*g)),p.fill(-1);let f=0,_=new Set;for(let t=h,e=3*u+h;t<e;t+=3){const e=t;for(let t=0;t<3;t++){let r=e+t;l&&(r=l.getX(r)),_hashes[t]=o(r)}for(let t=0;t<3;t++){const r=(t+1)%3,n=_hashes[t],i=_hashes[r],o=`${i}_${n}`;if(a.has(o)){const r=e+t,n=a.get(o);p[r]=n,p[n]=r,a.delete(o),f+=2,_.delete(n)}else{const r=`${n}_${i}`,o=e+t;a.set(r,o),_.add(o)}}}if(n){const{fragmentMap:e,disjointConnectivityMap:r}=computeDisjointEdges(t,_,i);_.clear(),e.forEach((({forward:t,reverse:e})=>{t.forEach((({index:t})=>_.add(t))),e.forEach((({index:t})=>_.add(t)))})),this.unmatchedDisjointEdges=e,this.disjointConnections=r,f=3*u-_.size}this.matchedEdges=f,this.unmatchedEdges=_.size,this.data=p}}class Brush extends Mesh{constructor(...t){super(...t),this.isBrush=!0,this._previousMatrix=new Matrix4,this._previousMatrix.elements.fill(0)}markUpdated(){this._previousMatrix.copy(this.matrix)}isDirty(){const{matrix:t,_previousMatrix:e}=this,r=t.elements,n=e.elements;for(let t=0;t<16;t++)if(r[t]!==n[t])return!0;return!1}prepareGeometry(){const t=this.geometry,e=t.attributes,r=areSharedArrayBuffersSupported();if(r)for(const t in e){const r=e[t];if(r.isInterleavedBufferAttribute)throw new Error("Brush: InterleavedBufferAttributes are not supported.");r.array=convertToSharedArrayBuffer(r.array)}if(t.boundsTree||(ensureIndex(t,{useSharedArrayBuffer:r}),t.boundsTree=new MeshBVH(t,{maxLeafTris:3,indirect:!0,useSharedArrayBuffer:r})),t.halfEdges||(t.halfEdges=new HalfEdgeMap(t)),!t.groupIndices){const e=getTriCount(t),r=new Uint16Array(e),n=t.groups;for(let t=0,e=n.length;t<e;t++){const{start:e,count:i}=n[t];for(let n=e/3,o=(e+i)/3;n<o;n++)r[n]=t}t.groupIndices=r}}disposeCacheData(){const{geometry:t}=this;t.halfEdges=null,t.boundsTree=null,t.groupIndices=null}}const EPSILON$1=1e-14,_AB=new Vector3,_AC=new Vector3,_CB=new Vector3;function isTriDegenerate(t,e=1e-14){_AB.subVectors(t.b,t.a),_AC.subVectors(t.c,t.a),_CB.subVectors(t.b,t.c);const r=_AB.angleTo(_AC),n=_AB.angleTo(_CB),i=Math.PI-r-n;return Math.abs(r)<e||Math.abs(n)<e||Math.abs(i)<e||t.a.distanceToSquared(t.b)<e||t.a.distanceToSquared(t.c)<e||t.b.distanceToSquared(t.c)<e}const EPSILON=1e-10,COPLANAR_EPSILON=1e-10,PARALLEL_EPSILON=1e-10,_edge$2=new Line3,_foundEdge=new Line3,_vec$1=new Vector3,_triangleNormal=new Vector3,_planeNormal=new Vector3,_plane$1=new Plane,_splittingTriangle=new ExtendedTriangle;class TrianglePool{constructor(){this._pool=[],this._index=0}getTriangle(){return this._index>=this._pool.length&&this._pool.push(new Triangle),this._pool[this._index++]}clear(){this._index=0}reset(){this._pool.length=0,this._index=0}}class TriangleSplitter{constructor(){this.trianglePool=new TrianglePool,this.triangles=[],this.normal=new Vector3,this.coplanarTriangleUsed=!1}initialize(t){this.reset();const{triangles:e,trianglePool:r,normal:n}=this;if(Array.isArray(t))for(let i=0,o=t.length;i<o;i++){const o=t[i];if(0===i)o.getNormal(n);else if(Math.abs(1-o.getNormal(_vec$1).dot(n))>1e-10)throw new Error("Triangle Splitter: Cannot initialize with triangles that have different normals.");const a=r.getTriangle();a.copy(o),e.push(a)}else{t.getNormal(n);const i=r.getTriangle();i.copy(t),e.push(i)}}splitByTriangle(t){const{normal:e,triangles:r}=this;if(t.getNormal(_triangleNormal).normalize(),Math.abs(1-Math.abs(_triangleNormal.dot(e)))<1e-10){this.coplanarTriangleUsed=!0;for(let t=0,e=r.length;t<e;t++){r[t].coplanarCount=0}const e=[t.a,t.b,t.c];for(let r=0;r<3;r++){const n=(r+1)%3,i=e[r],o=e[n];_vec$1.subVectors(o,i).normalize(),_planeNormal.crossVectors(_triangleNormal,_vec$1),_plane$1.setFromNormalAndCoplanarPoint(_planeNormal,i),this.splitByPlane(_plane$1,t)}}else t.getPlane(_plane$1),this.splitByPlane(_plane$1,t)}splitByPlane(t,e){const{triangles:r,trianglePool:n}=this;_splittingTriangle.copy(e),_splittingTriangle.needsUpdate=!0;for(let e=0,i=r.length;e<i;e++){const o=r[e];if(!_splittingTriangle.intersectsTriangle(o,_edge$2,!0))continue;const{a:a,b:s,c:c}=o;let l=0,d=-1,u=!1,g=[],h=[];const p=[a,s,c];for(let e=0;e<3;e++){const r=(e+1)%3;_edge$2.start.copy(p[e]),_edge$2.end.copy(p[r]);const n=t.distanceToPoint(_edge$2.start),i=t.distanceToPoint(_edge$2.end);if(Math.abs(n)<1e-10&&Math.abs(i)<1e-10){u=!0;break}if(n>0?g.push(e):h.push(e),Math.abs(n)<1e-10)continue;let o=!!t.intersectLine(_edge$2,_vec$1);!o&&Math.abs(i)<1e-10&&(_vec$1.copy(_edge$2.end),o=!0),!o||_vec$1.distanceTo(_edge$2.start)<1e-10||(_vec$1.distanceTo(_edge$2.end)<1e-10&&(d=e),0===l?_foundEdge.start.copy(_vec$1):_foundEdge.end.copy(_vec$1),l++)}if(!u&&2===l&&_foundEdge.distance()>1e-10)if(-1!==d){d=(d+1)%3;let t=0;t===d&&(t=(t+1)%3);let a=t+1;a===d&&(a=(a+1)%3);const s=n.getTriangle();s.a.copy(p[a]),s.b.copy(_foundEdge.end),s.c.copy(_foundEdge.start),isTriDegenerate(s)||r.push(s),o.a.copy(p[t]),o.b.copy(_foundEdge.start),o.c.copy(_foundEdge.end),isTriDegenerate(o)&&(r.splice(e,1),e--,i--)}else{const t=g.length>=2?h[0]:g[0];if(0===t){let t=_foundEdge.start;_foundEdge.start=_foundEdge.end,_foundEdge.end=t}const a=(t+1)%3,s=(t+2)%3,c=n.getTriangle(),l=n.getTriangle();p[a].distanceToSquared(_foundEdge.start)<p[s].distanceToSquared(_foundEdge.end)?(c.a.copy(p[a]),c.b.copy(_foundEdge.start),c.c.copy(_foundEdge.end),l.a.copy(p[a]),l.b.copy(p[s]),l.c.copy(_foundEdge.start)):(c.a.copy(p[s]),c.b.copy(_foundEdge.start),c.c.copy(_foundEdge.end),l.a.copy(p[a]),l.b.copy(p[s]),l.c.copy(_foundEdge.end)),o.a.copy(p[t]),o.b.copy(_foundEdge.end),o.c.copy(_foundEdge.start),isTriDegenerate(c)||r.push(c),isTriDegenerate(l)||r.push(l),isTriDegenerate(o)&&(r.splice(e,1),e--,i--)}else 3===l&&console.warn("TriangleClipper: Coplanar clip not handled")}}reset(){this.triangles.length=0,this.trianglePool.clear(),this.coplanarTriangleUsed=!1}}function ceilToFourByteStride(t){return(t=~~t)+4-t%4}class TypeBackedArray{constructor(t,e=500){this.expansionFactor=1.5,this.type=t,this.length=0,this.array=null,this.setSize(e)}setType(t){if(0!==this.length)throw new Error("TypeBackedArray: Cannot change the type while there is used data in the buffer.");const e=this.array.buffer;this.array=new t(e),this.type=t}setSize(t){if(this.array&&t===this.array.length)return;const e=this.type,r=new e(new(areSharedArrayBuffersSupported()?SharedArrayBuffer:ArrayBuffer)(ceilToFourByteStride(t*e.BYTES_PER_ELEMENT)));this.array&&r.set(this.array,0),this.array=r}expand(){const{array:t,expansionFactor:e}=this;this.setSize(t.length*e)}push(...t){let{array:e,length:r}=this;r+t.length>e.length&&(this.expand(),e=this.array);for(let n=0,i=t.length;n<i;n++)e[r+n]=t[n];this.length+=t.length}clear(){this.length=0}}class TypedAttributeData{constructor(){this.groupAttributes=[{}],this.groupCount=0}getType(t){return this.groupAttributes[0][t].type}getItemSize(t){return this.groupAttributes[0][t].itemSize}getNormalized(t){return this.groupAttributes[0][t].normalized}getCount(t){if(this.groupCount<=t)return 0;const e=this.getGroupAttrArray("position",t);return e.length/e.itemSize}getTotalLength(t){const{groupCount:e,groupAttributes:r}=this;let n=0;for(let i=0;i<e;i++){n+=r[i][t].length}return n}getGroupAttrSet(t=0){const{groupAttributes:e}=this;if(e[t])return this.groupCount=Math.max(this.groupCount,t+1),e[t];const r=e[0];for(this.groupCount=Math.max(this.groupCount,t+1);t>=e.length;){const t={};e.push(t);for(const e in r){const n=r[e],i=new TypeBackedArray(n.type);i.itemSize=n.itemSize,i.normalized=n.normalized,t[e]=i}}return e[t]}getGroupAttrArray(t,e=0){const{groupAttributes:r}=this;if(!r[0][t])throw new Error(`TypedAttributeData: Attribute with "${t}" has not been initialized`);return this.getGroupAttrSet(e)[t]}initializeArray(t,e,r,n){const{groupAttributes:i}=this,o=i[0][t];if(o){if(o.type!==e)for(let o=0,a=i.length;o<a;o++){const a=i[o][t];a.setType(e),a.itemSize=r,a.normalized=n}}else for(let o=0,a=i.length;o<a;o++){const a=new TypeBackedArray(e);a.itemSize=r,a.normalized=n,i[o][t]=a}}clear(){this.groupCount=0;const{groupAttributes:t}=this;t.forEach((t=>{for(const e in t)t[e].clear()}))}delete(t){this.groupAttributes.forEach((e=>{delete e[t]}))}reset(){this.groupAttributes=[],this.groupCount=0}}class IntersectionMap{constructor(){this.intersectionSet={},this.ids=[]}add(t,e){const{intersectionSet:r,ids:n}=this;r[t]||(r[t]=[],n.push(t)),r[t].push(e)}}const ADDITION=0,SUBTRACTION=1,REVERSE_SUBTRACTION=2,INTERSECTION=3,DIFFERENCE=4,HOLLOW_SUBTRACTION=5,HOLLOW_INTERSECTION=6,_ray$1=new Ray,_matrix$2=new Matrix4,_tri$2=new Triangle,_vec3=new Vector3,_vec4a=new Vector4,_vec4b=new Vector4,_vec4c=new Vector4,_vec4_0=new Vector4,_vec4_1=new Vector4,_vec4_2=new Vector4,_edge$1=new Line3,_normal$1=new Vector3,JITTER_EPSILON=1e-8,OFFSET_EPSILON=1e-15,BACK_SIDE=-1,FRONT_SIDE=1,COPLANAR_OPPOSITE=-2,COPLANAR_ALIGNED=2,INVERT_TRI=0,ADD_TRI=1,SKIP_TRI=2,FLOATING_COPLANAR_EPSILON=1e-14;let _debugContext=null;function setDebugContext(t){_debugContext=t}function getHitSide(t,e){t.getMidpoint(_ray$1.origin),t.getNormal(_ray$1.direction);const r=e.raycastFirst(_ray$1,DoubleSide);return Boolean(r&&_ray$1.direction.dot(r.face.normal)>0)?-1:1}function getHitSideWithCoplanarCheck(t,e){function r(){return Math.random()-.5}t.getNormal(_normal$1),_ray$1.direction.copy(_normal$1),t.getMidpoint(_ray$1.origin);let n=0,i=1/0;for(let t=0;t<3;t++){_ray$1.direction.x+=1e-8*r(),_ray$1.direction.y+=1e-8*r(),_ray$1.direction.z+=1e-8*r(),_ray$1.direction.multiplyScalar(-1);const o=e.raycastFirst(_ray$1,DoubleSide);if(Boolean(o&&_ray$1.direction.dot(o.face.normal)>0)&&n++,null!==o&&(i=Math.min(i,o.distance)),i<=1e-15)return o.face.normal.dot(_normal$1)>0?2:-2;if(n/3>.5||(t-n+1)/3>.5)break}return n/3>.5?-1:1}function collectIntersectingTriangles(t,e){const r=new IntersectionMap,n=new IntersectionMap;return _matrix$2.copy(t.matrixWorld).invert().multiply(e.matrixWorld),t.geometry.boundsTree.bvhcast(e.geometry.boundsTree,_matrix$2,{intersectsTriangles(i,o,a,s){if(!isTriDegenerate(i)&&!isTriDegenerate(o)){let c=i.intersectsTriangle(o,_edge$1,!0);if(!c){const t=i.plane,e=o.plane,r=t.normal,n=e.normal;1===r.dot(n)&&Math.abs(t.constant-e.constant)<1e-14&&(c=!0)}if(c){let c=t.geometry.boundsTree.resolveTriangleIndex(a),l=e.geometry.boundsTree.resolveTriangleIndex(s);r.add(c,l),n.add(l,c),_debugContext&&(_debugContext.addEdge(_edge$1),_debugContext.addIntersectingTriangles(a,i,s,o))}}return!1}}),{aIntersections:r,bIntersections:n}}function appendAttributeFromTriangle(t,e,r,n,i,o,a=!1){const s=r.attributes,c=r.index,l=3*t,d=c.getX(l+0),u=c.getX(l+1),g=c.getX(l+2);for(const t in o){const r=s[t],c=o[t];if(!(t in s))throw new Error(`CSG Operations: Attribute ${t} not available on geometry.`);const l=r.itemSize;"position"===t?(_tri$2.a.fromBufferAttribute(r,d).applyMatrix4(n),_tri$2.b.fromBufferAttribute(r,u).applyMatrix4(n),_tri$2.c.fromBufferAttribute(r,g).applyMatrix4(n),pushBarycoordInterpolatedValues(_tri$2.a,_tri$2.b,_tri$2.c,e,3,c,a)):"normal"===t?(_tri$2.a.fromBufferAttribute(r,d).applyNormalMatrix(i),_tri$2.b.fromBufferAttribute(r,u).applyNormalMatrix(i),_tri$2.c.fromBufferAttribute(r,g).applyNormalMatrix(i),a&&(_tri$2.a.multiplyScalar(-1),_tri$2.b.multiplyScalar(-1),_tri$2.c.multiplyScalar(-1)),pushBarycoordInterpolatedValues(_tri$2.a,_tri$2.b,_tri$2.c,e,3,c,a,!0)):(_vec4a.fromBufferAttribute(r,d),_vec4b.fromBufferAttribute(r,u),_vec4c.fromBufferAttribute(r,g),pushBarycoordInterpolatedValues(_vec4a,_vec4b,_vec4c,e,l,c,a))}}function appendAttributesFromIndices(t,e,r,n,i,o,a,s=!1){appendAttributeFromIndex(t,n,i,o,a,s),appendAttributeFromIndex(s?r:e,n,i,o,a,s),appendAttributeFromIndex(s?e:r,n,i,o,a,s)}function getOperationAction(t,e,r=!1){switch(t){case 0:if(1===e||2===e&&!r)return 1;break;case 1:if(r){if(-1===e)return 0}else if(1===e||-2===e)return 1;break;case 2:if(r){if(1===e||-2===e)return 1}else if(-1===e)return 0;break;case 4:if(-1===e)return 0;if(1===e)return 1;break;case 3:if(-1===e||2===e&&!r)return 1;break;case 5:if(!r&&(1===e||-2===e))return 1;break;case 6:if(!r&&(-1===e||2===e))return 1;break;default:throw new Error(`Unrecognized CSG operation enum "${t}".`)}return 2}function pushBarycoordInterpolatedValues(t,e,r,n,i,o,a=!1,s=!1){const c=t=>{o.push(t.x),i>1&&o.push(t.y),i>2&&o.push(t.z),i>3&&o.push(t.w)};_vec4_0.set(0,0,0,0).addScaledVector(t,n.a.x).addScaledVector(e,n.a.y).addScaledVector(r,n.a.z),_vec4_1.set(0,0,0,0).addScaledVector(t,n.b.x).addScaledVector(e,n.b.y).addScaledVector(r,n.b.z),_vec4_2.set(0,0,0,0).addScaledVector(t,n.c.x).addScaledVector(e,n.c.y).addScaledVector(r,n.c.z),s&&(_vec4_0.normalize(),_vec4_1.normalize(),_vec4_2.normalize()),c(_vec4_0),a?(c(_vec4_2),c(_vec4_1)):(c(_vec4_1),c(_vec4_2))}function appendAttributeFromIndex(t,e,r,n,i,o=!1){for(const a in i){const s=e[a],c=i[a];if(!(a in e))throw new Error(`CSG Operations: Attribute ${a} no available on geometry.`);const l=s.itemSize;"position"===a?(_vec3.fromBufferAttribute(s,t).applyMatrix4(r),c.push(_vec3.x,_vec3.y,_vec3.z)):"normal"===a?(_vec3.fromBufferAttribute(s,t).applyNormalMatrix(n),o&&_vec3.multiplyScalar(-1),c.push(_vec3.x,_vec3.y,_vec3.z)):(c.push(s.getX(t)),l>1&&c.push(s.getY(t)),l>2&&c.push(s.getZ(t)),l>3&&c.push(s.getW(t)))}}class TriangleIntersectData{constructor(t){this.triangle=(new Triangle).copy(t),this.intersects={}}addTriangle(t,e){this.intersects[t]=(new Triangle).copy(e)}getIntersectArray(){const t=[],{intersects:e}=this;for(const r in e)t.push(e[r]);return t}}class TriangleIntersectionSets{constructor(){this.data={}}addTriangleIntersection(t,e,r,n){const{data:i}=this;i[t]||(i[t]=new TriangleIntersectData(e)),i[t].addTriangle(r,n)}getTrianglesAsArray(t=null){const{data:e}=this,r=[];if(null!==t)t in e&&r.push(e[t].triangle);else for(const t in e)r.push(e[t].triangle);return r}getTriangleIndices(){return Object.keys(this.data).map((t=>parseInt(t)))}getIntersectionIndices(t){const{data:e}=this;return e[t]?Object.keys(e[t].intersects).map((t=>parseInt(t))):[]}getIntersectionsAsArray(t=null,e=null){const{data:r}=this,n=new Set,i=[],o=t=>{if(r[t])if(null!==e)r[t].intersects[e]&&i.push(r[t].intersects[e]);else{const e=r[t].intersects;for(const t in e)n.has(t)||(n.add(t),i.push(e[t]))}};if(null!==t)o(t);else for(const t in r)o(t);return i}reset(){this.data={}}}class OperationDebugData{constructor(){this.enabled=!1,this.triangleIntersectsA=new TriangleIntersectionSets,this.triangleIntersectsB=new TriangleIntersectionSets,this.intersectionEdges=[]}addIntersectingTriangles(t,e,r,n){const{triangleIntersectsA:i,triangleIntersectsB:o}=this;i.addTriangleIntersection(t,e,r,n),o.addTriangleIntersection(r,n,t,e)}addEdge(t){this.intersectionEdges.push(t.clone())}reset(){this.triangleIntersectsA.reset(),this.triangleIntersectsB.reset(),this.intersectionEdges=[]}init(){this.enabled&&(this.reset(),setDebugContext(this))}complete(){this.enabled&&setDebugContext(null)}}const _matrix$1=new Matrix4,_normalMatrix=new Matrix3,_triA=new Triangle,_triB=new Triangle,_tri$1=new Triangle,_barycoordTri=new Triangle,_attr=[],_actions=[];function getFirstIdFromSet(t){for(const e of t)return e}function performOperation(t,e,r,n,i,o={}){const{useGroups:a=!0}=o,{aIntersections:s,bIntersections:c}=collectIntersectingTriangles(t,e);let l;l=a?0:-1,performSplitTriangleOperations(t,e,s,r,!1,n,i,l),performWholeTriangleOperations(t,e,s,r,!1,i,l);return-1!==r.findIndex((t=>6!==t&&5!==t))&&(l=a?t.geometry.groups.length||1:-1,performSplitTriangleOperations(e,t,c,r,!0,n,i,l),performWholeTriangleOperations(e,t,c,r,!0,i,l)),_attr.length=0,_actions.length=0,{groups:[],materials:null}}function performSplitTriangleOperations(t,e,r,n,i,o,a,s=0){const c=t.matrixWorld.determinant()<0;_matrix$1.copy(e.matrixWorld).invert().multiply(t.matrixWorld),_normalMatrix.getNormalMatrix(t.matrixWorld).multiplyScalar(c?-1:1);const l=t.geometry.groupIndices,d=t.geometry.index,u=t.geometry.attributes.position,g=e.geometry.boundsTree,h=e.geometry.index,p=e.geometry.attributes.position,f=r.ids,_=r.intersectionSet;for(let e=0,r=f.length;e<r;e++){const r=f[e],m=-1===s?0:l[r]+s,y=3*r,b=d.getX(y+0),x=d.getX(y+1),T=d.getX(y+2);_triA.a.fromBufferAttribute(u,b).applyMatrix4(_matrix$1),_triA.b.fromBufferAttribute(u,x).applyMatrix4(_matrix$1),_triA.c.fromBufferAttribute(u,T).applyMatrix4(_matrix$1),o.reset(),o.initialize(_triA);const A=_[r];for(let t=0,e=A.length;t<e;t++){const e=3*A[t],r=h.getX(e+0),n=h.getX(e+1),i=h.getX(e+2);_triB.a.fromBufferAttribute(p,r),_triB.b.fromBufferAttribute(p,n),_triB.c.fromBufferAttribute(p,i),o.splitByTriangle(_triB)}const w=o.triangles;for(let e=0,s=w.length;e<s;e++){const s=w[e],l=o.coplanarTriangleUsed?getHitSideWithCoplanarCheck(s,g):getHitSide(s,g);_attr.length=0,_actions.length=0;for(let t=0,e=n.length;t<e;t++){const e=getOperationAction(n[t],l,i);2!==e&&(_actions.push(e),_attr.push(a[t].getGroupAttrSet(m)))}if(0!==_attr.length){_triA.getBarycoord(s.a,_barycoordTri.a),_triA.getBarycoord(s.b,_barycoordTri.b),_triA.getBarycoord(s.c,_barycoordTri.c);for(let e=0,n=_attr.length;e<n;e++){const n=_attr[e],i=0===_actions[e];appendAttributeFromTriangle(r,_barycoordTri,t.geometry,t.matrixWorld,_normalMatrix,n,c!==i)}}}}return f.length}function performWholeTriangleOperations(t,e,r,n,i,o,a=0){const s=t.matrixWorld.determinant()<0;_matrix$1.copy(e.matrixWorld).invert().multiply(t.matrixWorld),_normalMatrix.getNormalMatrix(t.matrixWorld).multiplyScalar(s?-1:1);const c=e.geometry.boundsTree,l=t.geometry.groupIndices,d=t.geometry.index,u=t.geometry.attributes,g=u.position,h=[],p=t.geometry.halfEdges,f=new Set;for(let e=0,n=getTriCount(t.geometry);e<n;e++)e in r.intersectionSet||f.add(e);for(;f.size>0;){const e=getFirstIdFromSet(f);f.delete(e),h.push(e);const r=3*e,_=d.getX(r+0),m=d.getX(r+1),y=d.getX(r+2);_tri$1.a.fromBufferAttribute(g,_).applyMatrix4(_matrix$1),_tri$1.b.fromBufferAttribute(g,m).applyMatrix4(_matrix$1),_tri$1.c.fromBufferAttribute(g,y).applyMatrix4(_matrix$1);const b=getHitSide(_tri$1,c);_actions.length=0,_attr.length=0;for(let t=0,e=n.length;t<e;t++){const e=getOperationAction(n[t],b,i);2!==e&&(_actions.push(e),_attr.push(o[t]))}for(;h.length>0;){const e=h.pop();for(let t=0;t<3;t++){const r=p.getSiblingTriangleIndex(e,t);-1!==r&&f.has(r)&&(h.push(r),f.delete(r))}if(0!==_attr.length){const r=3*e,n=d.getX(r+0),i=d.getX(r+1),o=d.getX(r+2),c=-1===a?0:l[e]+a;if(_tri$1.a.fromBufferAttribute(g,n),_tri$1.b.fromBufferAttribute(g,i),_tri$1.c.fromBufferAttribute(g,o),!isTriDegenerate(_tri$1))for(let e=0,r=_attr.length;e<r;e++){const r=_actions[e],a=_attr[e].getGroupAttrSet(c),l=0===r;appendAttributesFromIndices(n,i,o,u,t.matrixWorld,_normalMatrix,a,l!==s)}}}}}function joinGroups(t){for(let e=0;e<t.length-1;e++){const r=t[e],n=t[e+1];if(r.materialIndex===n.materialIndex){const i=r.start,o=n.start+n.count;n.start=i,n.count=o-i,t.splice(e,1),e--}}}function prepareAttributesData(t,e,r,n){r.clear();const i=t.attributes;for(let t=0,e=n.length;t<e;t++){const e=n[t],o=i[e];r.initializeArray(e,o.array.constructor,o.itemSize,o.normalized)}for(const t in r.attributes)n.includes(t)||r.delete(t);for(const t in e.attributes)n.includes(t)||(e.deleteAttribute(t),e.dispose())}function assignBufferData(t,e,r){let n=!1,i=-1;const o=t.attributes,a=e.groupAttributes[0];for(const s in a){const a=e.getTotalLength(s),c=e.getType(s),l=e.getItemSize(s),d=e.getNormalized(s);let u=o[s];(!u||u.array.length<a)&&(u=new BufferAttribute(new c(a),l,d),t.setAttribute(s,u),n=!0);let g=0;for(let t=0,n=Math.min(r.length,e.groupCount);t<n;t++){const n=r[t].index,{array:i,type:o,length:a}=e.groupAttributes[n][s],c=new o(i.buffer,0,a);u.array.set(c,g),g+=c.length}u.needsUpdate=!0,i=a/u.itemSize}if(t.index){const e=t.index.array;if(e.length<i)t.index=null,n=!0;else for(let t=0,r=e.length;t<r;t++)e[t]=t}let s=0;t.clearGroups();for(let n=0,i=Math.min(r.length,e.groupCount);n<i;n++){const{index:i,materialIndex:o}=r[n],a=e.getCount(i);0!==a&&(t.addGroup(s,a,o),s+=a)}t.setDrawRange(0,i),t.boundsTree=null,n&&t.dispose()}function getMaterialList(t,e){let r=e;return Array.isArray(e)||(r=[],t.forEach((t=>{r[t.materialIndex]=e}))),r}class Evaluator{constructor(){this.triangleSplitter=new TriangleSplitter,this.attributeData=[],this.attributes=["position","uv","normal"],this.useGroups=!0,this.consolidateGroups=!0,this.debug=new OperationDebugData}getGroupRanges(t){return this.useGroups&&0!==t.groups.length?t.groups.map((t=>({...t}))):[{start:0,count:1/0,materialIndex:0}]}evaluate(t,e,r,n=new Brush){let i=!0;if(Array.isArray(r)||(r=[r]),Array.isArray(n)||(n=[n],i=!1),n.length!==r.length)throw new Error("Evaluator: operations and target array passed as different sizes.");t.prepareGeometry(),e.prepareGeometry();const{triangleSplitter:o,attributeData:a,attributes:s,useGroups:c,consolidateGroups:l,debug:d}=this;for(;a.length<n.length;)a.push(new TypedAttributeData);n.forEach(((e,r)=>{prepareAttributesData(t.geometry,e.geometry,a[r],s)})),d.init(),performOperation(t,e,r,o,a,{useGroups:c}),d.complete();const u=this.getGroupRanges(t.geometry),g=getMaterialList(u,t.material),h=this.getGroupRanges(e.geometry),p=getMaterialList(h,e.material);h.forEach((t=>t.materialIndex+=g.length));let f=[...u,...h].map(((t,e)=>({...t,index:e})));if(c){const t=[...g,...p];l&&(f=f.map((e=>{const r=t[e.materialIndex];return e.materialIndex=t.indexOf(r),e})).sort(((t,e)=>t.materialIndex-e.materialIndex)));const e=[];for(let r=0,n=t.length;r<n;r++){let n=!1;for(let t=0,i=f.length;t<i;t++){const i=f[t];i.materialIndex===r&&(n=!0,i.materialIndex=e.length)}n&&e.push(t[r])}n.forEach((t=>{t.material=e}))}else f=[{start:0,count:1/0,index:0,materialIndex:0}],n.forEach((t=>{t.material=g[0]}));return n.forEach(((t,e)=>{const r=t.geometry;assignBufferData(r,a[e],f),l&&joinGroups(r.groups)})),i?n:n[0]}evaluateHierarchy(t,e=new Brush){t.updateMatrixWorld(!0);const r=(t,e)=>{const n=t.children;for(let t=0,i=n.length;t<i;t++){const i=n[t];i.isOperationGroup?r(i,e):e(i)}},n=t=>{const e=t.children;let i=!1;for(let t=0,r=e.length;t<r;t++){const r=e[t];i=n(r)||i}const o=t.isDirty();if(o&&t.markUpdated(),i&&!t.isOperationGroup){let e;return r(t,(r=>{e=e?this.evaluate(e,r,r.operation):this.evaluate(t,r,r.operation)})),t._cachedGeometry=e.geometry,t._cachedMaterials=e.material,!0}return i||o};return n(t),e.geometry=t._cachedGeometry,e.material=t._cachedMaterials,e}reset(){this.triangleSplitter.reset()}}class Operation extends Brush{constructor(...t){super(...t),this.isOperation=!0,this.operation=0,this._cachedGeometry=new BufferGeometry,this._cachedMaterials=null,this._previousOperation=null}markUpdated(){super.markUpdated(),this._previousOperation=this.operation}isDirty(){return this.operation!==this._previousOperation||super.isDirty()}insertBefore(t){const e=this.parent,r=e.children.indexOf(this);e.children.splice(r,0,t)}insertAfter(t){const e=this.parent,r=e.children.indexOf(this);e.children.splice(r+1,0,t)}}class OperationGroup extends Group{constructor(){super(),this.isOperationGroup=!0,this._previousMatrix=new Matrix4}markUpdated(){this._previousMatrix.copy(this.matrix)}isDirty(){const{matrix:t,_previousMatrix:e}=this,r=t.elements,n=e.elements;for(let t=0;t<16;t++)if(r[t]!==n[t])return!0;return!1}}function addWorldPosition(t){if(!/varying\s+vec3\s+wPosition/.test(t.vertexShader))return t.vertexShader=`\n\t\t\tvarying vec3 wPosition;\n\t\t\t${t.vertexShader}\n\t\t`.replace(/#include <displacementmap_vertex>/,(t=>`${t}\n\t\t\t\twPosition = (modelMatrix * vec4( transformed, 1.0 )).xyz;\n\t\t\t\t`)),t.fragmentShader=`\n\t\tvarying vec3 wPosition;\n\t\t${t.fragmentShader}\n\t\t`,t}function csgGridShaderMixin(t){return t.uniforms={...t.uniforms,checkerboardColor:{value:new Color(1118481)}},addWorldPosition(t),t.defines={CSG_GRID:1},t.fragmentShader=t.fragmentShader.replace(/#include <common>/,(t=>`\n\t\t\t${t}\n\n\t\t\tuniform vec3 checkerboardColor;\n\t\t\tfloat getCheckerboard( vec2 p, float scale ) {\n\n\t\t\t\tp /= scale;\n\t\t\t\tp += vec2( 0.5 );\n\n\t\t\t\tvec2 line = mod( p, 2.0 ) - vec2( 1.0 );\n\t\t\t\tline = abs( line );\n\n\t\t\t\tvec2 pWidth = fwidth( line );\n\t\t\t\tvec2 value = smoothstep( 0.5 - pWidth / 2.0, 0.5 + pWidth / 2.0, line );\n\t\t\t\tfloat result = value.x * value.y + ( 1.0 - value.x ) * ( 1.0 - value.y );\n\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t\tfloat getGrid( vec2 p, float scale, float thickness ) {\n\n\t\t\t\tp /= 0.5 * scale;\n\n\t\t\t\tvec2 stride = mod( p, 2.0 ) - vec2( 1.0 );\n\t\t\t\tstride = abs( stride );\n\n\t\t\t\tvec2 pWidth = fwidth( p );\n\t\t\t\tvec2 line = smoothstep( 1.0 - pWidth / 2.0, 1.0 + pWidth / 2.0, stride + thickness * pWidth );\n\n\t\t\t\treturn max( line.x, line.y );\n\n\t\t\t}\n\n\t\t\tvec3 getFaceColor( vec2 p, vec3 color ) {\n\n\t\t\t\tfloat checkLarge = getCheckerboard( p, 1.0 );\n\t\t\t\tfloat checkSmall = abs( getCheckerboard( p, 0.1 ) );\n\t\t\t\tfloat lines = getGrid( p, 10.0, 1.0 );\n\n\t\t\t\tvec3 checkColor = mix(\n\t\t\t\t\tvec3( 0.7 ) * color,\n\t\t\t\t\tvec3( 1.0 ) * color,\n\t\t\t\t\tcheckSmall * 0.4 + checkLarge * 0.6\n\t\t\t\t);\n\n\t\t\t\tvec3 gridColor = vec3( 1.0 );\n\n\t\t\t\treturn mix( checkColor, gridColor, lines );\n\n\t\t\t}\n\n\t\t\tfloat angleBetween( vec3 a, vec3 b ) {\n\n\t\t\t\treturn acos( abs( dot( a, b ) ) );\n\n\t\t\t}\n\n\t\t\tvec3 planeProject( vec3 norm, vec3 other ) {\n\n\t\t\t\tfloat d = dot( norm, other );\n\t\t\t\treturn normalize( other - norm * d );\n\n\t\t\t}\n\n\t\t\tvec3 getBlendFactors( vec3 norm ) {\n\n\t\t\t\tvec3 xVec = vec3( 1.0, 0.0, 0.0 );\n\t\t\t\tvec3 yVec = vec3( 0.0, 1.0, 0.0 );\n\t\t\t\tvec3 zVec = vec3( 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 projX = planeProject( xVec, norm );\n\t\t\t\tvec3 projY = planeProject( yVec, norm );\n\t\t\t\tvec3 projZ = planeProject( zVec, norm );\n\n\t\t\t\tfloat xAngle = max(\n\t\t\t\t\tangleBetween( xVec, projY ),\n\t\t\t\t\tangleBetween( xVec, projZ )\n\t\t\t\t);\n\n\t\t\t\tfloat yAngle = max(\n\t\t\t\t\tangleBetween( yVec, projX ),\n\t\t\t\t\tangleBetween( yVec, projZ )\n\t\t\t\t);\n\n\t\t\t\tfloat zAngle = max(\n\t\t\t\t\tangleBetween( zVec, projX ),\n\t\t\t\t\tangleBetween( zVec, projY )\n\t\t\t\t);\n\n\t\t\t\treturn vec3( xAngle, yAngle, zAngle ) / ( 0.5 * PI );\n\n\t\t\t}\n\t\t`)).replace(/#include <normal_fragment_maps>/,(t=>`${t}\n\t\t\t\t#if CSG_GRID\n\t\t\t\t{\n\n\t\t\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\t\t\t\t\tfloat yCont = abs( dot( vec3( 0.0, 1.0, 0.0 ), worldNormal ) );\n\t\t\t\t\tfloat zCont = abs( dot( vec3( 0.0, 0.0, 1.0 ), worldNormal ) );\n\t\t\t\t\tfloat xCont = abs( dot( vec3( 1.0, 0.0, 0.0 ), worldNormal ) );\n\n\t\t\t\t\tvec3 factors = getBlendFactors( worldNormal );\n\t\t\t\t\tfactors = smoothstep( vec3( 0.475 ), vec3( 0.525 ), vec3( 1.0 ) - factors );\n\n\t\t\t\t\tfloat weight = factors.x + factors.y + factors.z;\n\t\t\t\t\tfactors /= weight;\n\n\t\t\t\t\tvec3 color =\n\t\t\t\t\t\tgetFaceColor( wPosition.yz, diffuseColor.rgb ) * factors.x +\n\t\t\t\t\t\tgetFaceColor( wPosition.xz, diffuseColor.rgb ) * factors.y +\n\t\t\t\t\t\tgetFaceColor( wPosition.xy, diffuseColor.rgb ) * factors.z;\n\n\t\t\t\t\tdiffuseColor.rgb = color;\n\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t\t`)),t}class GridMaterial extends MeshPhongMaterial{get enableGrid(){return Boolean(this._enableGrid)}set enableGrid(t){this._enableGrid!==t&&(this._enableGrid=t,this.needsUpdate=!0)}constructor(...t){super(...t),this.enableGrid=!0}onBeforeCompile(t){csgGridShaderMixin(t),t.defines.CSG_GRID=Number(this.enableGrid)}customProgramCacheKey(){return this.enableGrid.toString()}}function getTriangleDefinitions(...t){function e(t){return`new THREE.Vector3( ${t.x}, ${t.y}, ${t.z} )`}return t.map((t=>`\nnew THREE.Triangle(\n\t${e(t.a)},\n\t${e(t.b)},\n\t${e(t.c)},\n)\n\t\t`.trim()))}function logTriangleDefinitions(...t){console.log(getTriangleDefinitions(...t).join(",\n"))}function generateRandomTriangleColors(t){const e=t.attributes.position,r=new Float32Array(3*e.count),n=new Color;for(let t=0,e=r.length;t<e;t+=9)n.setHSL(Math.random(),MathUtils.lerp(.5,1,Math.random()),MathUtils.lerp(.5,.75,Math.random())),r[t+0]=n.r,r[t+1]=n.g,r[t+2]=n.b,r[t+3]=n.r,r[t+4]=n.g,r[t+5]=n.b,r[t+6]=n.r,r[t+7]=n.g,r[t+8]=n.b;t.setAttribute("color",new BufferAttribute(r,3))}class TriangleSetHelper extends Group{get color(){return this._mesh.material.color}get side(){return this._mesh.material.side}set side(t){this._mesh.material.side=t}constructor(t=[]){super();const e=new BufferGeometry,r=new BufferGeometry;this._mesh=new Mesh(e,new MeshPhongMaterial({flatShading:!0,transparent:!0,opacity:.25,depthWrite:!1})),this._lines=new LineSegments(r,new LineBasicMaterial),this._mesh.material.color=this._lines.material.color,this._lines.frustumCulled=!1,this._mesh.frustumCulled=!1,this.add(this._lines,this._mesh),this.setTriangles(t)}setTriangles(t){const e=new Float32Array(9*t.length),r=new Float32Array(18*t.length);for(let n=0,i=t.length;n<i;n++){const i=9*n,o=18*n,a=t[n];a.a.toArray(e,i+0),a.b.toArray(e,i+3),a.c.toArray(e,i+6),a.a.toArray(r,o+0),a.b.toArray(r,o+3),a.b.toArray(r,o+6),a.c.toArray(r,o+9),a.c.toArray(r,o+12),a.a.toArray(r,o+15)}this._mesh.geometry.dispose(),this._mesh.geometry.setAttribute("position",new BufferAttribute(e,3)),this._lines.geometry.dispose(),this._lines.geometry.setAttribute("position",new BufferAttribute(r,3))}}class EdgesHelper extends LineSegments{get color(){return this.material.color}constructor(t=[]){super(),this.frustumCulled=!1,this.setEdges(t)}setEdges(t){const{geometry:e}=this,r=t.flatMap((t=>[t.start,t.end]));e.dispose(),e.setFromPoints(r)}}const _matrix=new Matrix4;class PointsHelper extends InstancedMesh{get color(){return this.material.color}constructor(t=1e3,e=[]){super(new SphereGeometry(.025),new MeshBasicMaterial,t),this.frustumCulled=!1,this.setPoints(e)}setPoints(t){for(let e=0,r=t.length;e<r;e++){const r=t[e];_matrix.makeTranslation(r.x,r.y,r.z),this.setMatrixAt(e,_matrix)}this.count=t.length}}const vertKeys=["a","b","c"],_tri1=new Triangle,_tri2=new Triangle,_center=new Vector3,_center2=new Vector3,_projected=new Vector3,_projected2=new Vector3,_projectedDir=new Vector3,_projectedDir2=new Vector3,_edgeDir=new Vector3,_edgeDir2=new Vector3,_vec=new Vector3,_vec2=new Vector3,_finalPoint=new Vector3,_finalPoint2=new Vector3,_plane=new Plane,_plane2=new Plane,_centerPoint=new Vector3,_ray=new Ray,_edge=new Line3;function getTriangle(t,e,r){const n=3*e;let i=n+0,o=n+1,a=n+2;const s=t.index,c=t.attributes.position;return s&&(i=s.getX(i),o=s.getX(o),a=s.getX(a)),r.a.fromBufferAttribute(c,i),r.b.fromBufferAttribute(c,o),r.c.fromBufferAttribute(c,a),r}function getOverlapEdge(t,e,r,n,i){const o=(e+1)%3,a=t[vertKeys[e]],s=t[vertKeys[o]],c=(n+1)%3,l=r[vertKeys[n]],d=r[vertKeys[c]];toNormalizedRay(a,s,_ray);let u=_vec.subVectors(a,_ray.origin).dot(_ray.direction),g=_vec.subVectors(s,_ray.origin).dot(_ray.direction);u>g&&([u,g]=[g,u]);let h=_vec.subVectors(l,_ray.origin).dot(_ray.direction),p=_vec.subVectors(d,_ray.origin).dot(_ray.direction);h>p&&([h,p]=[p,h]);const f=Math.max(u,h),_=Math.min(g,p);_ray.at(f,i.start),_ray.at(_,i.end)}class HalfEdgeHelper extends EdgesHelper{constructor(t=null,e=null){super(),this.straightEdges=!1,this.displayDisconnectedEdges=!1,t&&e&&this.setHalfEdges(t,e)}setHalfEdges(t,e){const{straightEdges:r,displayDisconnectedEdges:n}=this,i=[],o=t.drawRange.start;let a=getTriCount(t);if(t.drawRange.count!==1/0&&(a=~~(t.drawRange.count/3)),n)if(e.unmatchedDisjointEdges)e.unmatchedDisjointEdges.forEach((({forward:t,reverse:e,ray:r})=>{[...t,...e].forEach((({start:t,end:e})=>{const n=new Line3;r.at(t,n.start),r.at(e,n.end),i.push(n)}))}));else for(let r=o;r<a;r++){getTriangle(t,r,_tri1);for(let t=0;t<3;t++){if(-1===e.getSiblingTriangleIndex(r,t)){const e=(t+1)%3,r=_tri1[vertKeys[t]],n=_tri1[vertKeys[e]],o=new Line3;o.start.copy(r),o.end.copy(n),i.push(o)}}}else for(let r=o;r<a;r++){getTriangle(t,r,_tri1);for(let n=0;n<3;n++){const i=e.getSiblingTriangleIndex(r,n);if(-1===i)continue;getTriangle(t,i,_tri2);const o=(n+1)%3,a=_tri1[vertKeys[n]],c=_tri1[vertKeys[o]];_centerPoint.lerpVectors(a,c,.5),s(_tri1,_tri2,_centerPoint)}if(e.disjointConnections)for(let n=0;n<3;n++){const i=e.getDisjointSiblingTriangleIndices(r,n),o=e.getDisjointSiblingEdgeIndices(r,n);for(let e=0;e<i.length;e++){const r=i[e],a=o[e];getTriangle(t,r,_tri2),getOverlapEdge(_tri1,n,_tri2,a,_edge),_centerPoint.lerpVectors(_edge.start,_edge.end,.5),s(_tri1,_tri2,_centerPoint)}}}function s(t,e,n){t.getMidpoint(_center),e.getMidpoint(_center2),t.getPlane(_plane),e.getPlane(_plane2);const o=new Line3;o.start.copy(_center),r?(_plane.projectPoint(_center2,_projected),_plane2.projectPoint(_center,_projected2),_projectedDir.subVectors(_projected,_center),_projectedDir2.subVectors(_projected2,_center2),_edgeDir.subVectors(n,_center),_edgeDir2.subVectors(n,_center2),_projectedDir.dot(_edgeDir)<0&&_projectedDir.multiplyScalar(-1),_projectedDir2.dot(_edgeDir2)<0&&_projectedDir2.multiplyScalar(-1),_vec.addVectors(_center,_projectedDir),_vec2.addVectors(_center2,_projectedDir2),t.closestPointToPoint(_vec,_finalPoint),e.closestPointToPoint(_vec2,_finalPoint2),o.end.lerpVectors(_finalPoint,_finalPoint2,.5)):o.end.copy(n),i.push(o)}super.setEdges(i)}}const _tri=new Triangle,_normal=new Vector3,_relPoint=new Vector3;function computeMeshVolume(t){let e,r;t.isBufferGeometry?(e=t,r=null):(e=t.geometry,r=Math.abs(t.matrixWorld.determinant()-1)<1e-15?null:t.matrixWorld);const n=e.index,i=e.attributes.position,o=e.drawRange,a=Math.min(getTriCount(e),o.count/3);_tri.setFromAttributeAndIndices(i,0,1,2),applyMatrix4ToTri(_tri,r),_tri.getNormal(_normal),_tri.getMidpoint(_relPoint).add(_normal);let s=0;const c=o.start/3;for(let t=c,e=c+a;t<e;t++){let e=3*t+0,o=3*t+1,a=3*t+2;n&&(e=n.getX(e),o=n.getX(o),a=n.getX(a)),_tri.setFromAttributeAndIndices(i,e,o,a),applyMatrix4ToTri(_tri,r),subVectorFromTri(_tri,_relPoint),s+=signedVolumeOfTriangle(_tri.a,_tri.b,_tri.c)}return Math.abs(s)}function signedVolumeOfTriangle(t,e,r){return 1/6*(-(r.x*e.y*t.z)+e.x*r.y*t.z+r.x*t.y*e.z-t.x*r.y*e.z-e.x*t.y*r.z+t.x*e.y*r.z)}function subVectorFromTri(t,e){t.a.sub(e),t.b.sub(e),t.c.sub(e)}function applyMatrix4ToTri(t,e=null){null!==e&&(t.a.applyMatrix4(e),t.b.applyMatrix4(e),t.c.applyMatrix4(e))}export{ADDITION,Brush,DIFFERENCE,EdgesHelper,Evaluator,GridMaterial,HOLLOW_INTERSECTION,HOLLOW_SUBTRACTION,HalfEdgeHelper,HalfEdgeMap,INTERSECTION,Operation,OperationGroup,PointsHelper,REVERSE_SUBTRACTION,SUBTRACTION,TriangleSetHelper,TriangleSplitter,computeMeshVolume,generateRandomTriangleColors,getTriangleDefinitions,logTriangleDefinitions};
//# sourceMappingURL=/sm/d9997a624bf33fdc9ba737ddf30c14ddb28ac73644c335dd4d2dbb5b22cd56e2.map