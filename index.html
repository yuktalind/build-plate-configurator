<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CNC Build Plate Configurator</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #000;
      color: #fff;
      overflow: hidden;
    }
    
    #container {
      display: flex;
      width: 100vw;
      height: 100vh;
    }
    
    #controls {
      width: 280px;
      background: #000;
      padding: 24px;
      overflow-y: auto;
      flex-shrink: 0;
    }
    
    #controls h1 {
      font-size: 18px;
      font-weight: 600;
      color: #999;
      margin-bottom: 24px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .control-group {
      margin-bottom: 20px;
    }
    
    .control-group label {
      display: block;
      font-size: 12px;
      color: #888;
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }
    
    .control-group select,
    .control-group input {
      width: 100%;
      padding: 10px 12px;
      background: #333;
      border: 1px solid #555;
      color: #ccc;
      font-size: 14px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .control-group select:hover,
    .control-group input:hover {
      border-color: #777;
    }
    
    .control-group select:focus,
    .control-group input:focus {
      outline: none;
      border-color: #999;
      background: #3a3a3a;
    }
    
    .divider {
      height: 1px;
      background: #333;
      margin: 24px 0;
    }
    
    #info {
      font-size: 12px;
      color: #666;
      line-height: 1.8;
    }
    
    #info div {
      margin-bottom: 8px;
    }
    
    #info span {
      color: #999;
      font-weight: 500;
    }
    
    #canvas-container {
      flex: 1;
      position: relative;
      background: #000;
    }
    
    #plate-canvas {
      width: 100%;
      height: 100%;
      display: block;
      cursor: grab;
    }
    
    #plate-canvas:active {
      cursor: grabbing;
    }
    
    @media (max-width: 768px) {
      #container {
        flex-direction: column;
      }
      
      #controls {
        width: 100%;
        height: auto;
        max-height: 40vh;
      }
      
      #canvas-container {
        height: 60vh;
      }
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="controls">
      <h1>Configuration</h1>
      
      <div class="control-group">
        <label>Plate Size</label>
        <select id="plate-size">
          <option value="100x200">100 × 200 mm</option>
          <option value="200x200" selected>200 × 200 mm</option>
          <option value="200x300">200 × 300 mm</option>
          <option value="250x250">250 × 250 mm</option>
          <option value="300x300">300 × 300 mm</option>
          <option value="300x400">300 × 400 mm</option>
          <option value="400x400">400 × 400 mm</option>
          <option value="300x500">300 × 500 mm</option>
          <option value="400x500">400 × 500 mm</option>
        </select>
      </div>

      <div class="control-group">
        <label>Thickness (mm)</label>
        <select id="plate-thickness">
          <option value="9.8" selected>9.8 mm</option>
          <option value="10">10 mm</option>
          <option value="12.7">12.7 mm</option>
          <option value="15">15 mm</option>
        </select>
      </div>

      <div class="control-group">
        <label>Thread Type</label>
        <select id="thread-type">
          <option value="M6" selected>M6</option>
          <option value="M5">M5</option>
          <option value="M8">M8</option>
        </select>
      </div>

      <div class="control-group">
        <label>Thread Grid (mm)</label>
        <input id="thread-grid" type="number" value="25" min="10" max="50" step="5">
      </div>

      <div class="control-group">
        <label>Edge Margin (mm)</label>
        <input id="edge-margin" type="number" value="10" min="0" max="50" step="5">
      </div>

      <div class="divider"></div>

      <div id="info">
        <div>Thread depth: <span id="info-thread-depth">9.8mm</span></div>
        <div>Through-holes: <span id="info-through">Yes</span></div>
        <div>Mounting holes: <span id="info-mounting">4</span></div>
        <div>Mounting Ø: <span id="info-mounting-dia">6.2mm</span></div>
      </div>
    </div>

    <div id="canvas-container">
      <canvas id="plate-canvas"></canvas>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three-bvh-csg@0.0.16/build/bundle.umd.cjs"></script>
  <script>
    const { Brush, Evaluator, SUBTRACTION } = window.ThreeBVHCSG;
    const canvas = document.getElementById('plate-canvas');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    
    const camera = new THREE.PerspectiveCamera(
      45,
      canvas.clientWidth / canvas.clientHeight,
      0.1,
      2000
    );
    camera.position.set(0, 300, 400);
    camera.lookAt(0, 0, 0);
    
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(canvas.clientWidth, canvas.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambientLight);
    
    const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.6);
    directionalLight1.position.set(200, 300, 200);
    scene.add(directionalLight1);
    
    const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
    directionalLight2.position.set(-200, 200, -100);
    scene.add(directionalLight2);
    
    const aluminumMaterial = new THREE.MeshStandardMaterial({
      color: 0xc0c0c0,
      metalness: 0.8,
      roughness: 0.2,
      envMapIntensity: 1.0
    });
    
    let plateMesh;
    let autoRotate = true;
    let rotationY = 0;
    let rotationZ = -20 * Math.PI / 180;
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let velocity = { x: 0, y: 0 };
    
    function createThreadedHole(diameter, depth, isThrough) {
      const group = new THREE.Group();
      const threadPitch = diameter * 0.15;
      const threadHeight = diameter * 0.08;
      const ridges = Math.floor(depth / threadPitch);

      // Main hole cylinder
      const holeGeo = new THREE.CylinderGeometry(diameter / 2, diameter / 2, depth, 32);
      const holeMesh = new THREE.Mesh(holeGeo);
      holeMesh.updateMatrix();
      group.add(holeMesh);

      // Thread ridges (simplified as rings)
      for (let i = 0; i < ridges; i++) {
        const yPos = (i - ridges / 2) * threadPitch;
        const ringGeo = new THREE.TorusGeometry(
          diameter / 2 - threadHeight / 2,
          threadHeight,
          8,
          16
        );
        const ringMesh = new THREE.Mesh(ringGeo);
        ringMesh.rotation.x = Math.PI / 2;
        ringMesh.position.y = yPos;
        ringMesh.updateMatrix();
        group.add(ringMesh);
      }

      return group;
    }

    function createCounterbore(threadDia, boreDia, boreDepth, totalDepth) {
      const group = new THREE.Group();

      // Counterbore (Senkung)
      const boreGeo = new THREE.CylinderGeometry(boreDia / 2, boreDia / 2, boreDepth, 32);
      const boreMesh = new THREE.Mesh(boreGeo);
      boreMesh.position.y = (totalDepth - boreDepth) / 2;
      boreMesh.updateMatrix();
      group.add(boreMesh);

      // Through hole with threads
      const threadedHole = createThreadedHole(threadDia, totalDepth, true);
      group.add(threadedHole);

      return group;
    }

    function createPlate(width, depth, thickness) {
      if (plateMesh) scene.remove(plateMesh);

      // Start with solid plate
      const plateGeo = new THREE.BoxGeometry(width, thickness, depth);
      let plateBrush = new Brush(plateGeo);
      plateBrush.updateMatrixWorld();

      const threadGrid = parseFloat(document.getElementById('thread-grid').value);
      const edgeMargin = parseFloat(document.getElementById('edge-margin').value);
      const threadType = document.getElementById('thread-type').value;
      const threadDia = threadType === 'M5' ? 4.2 : threadType === 'M6' ? 5.0 : 6.8;
      const isThrough = thickness <= 9.8;
      const threadDepth = isThrough ? thickness : 9.8;

      const xHoles = Math.floor(width / threadGrid);
      const zHoles = Math.floor(depth / threadGrid);

      const evaluator = new Evaluator();

      // Subtract thread holes
      for (let i = 0; i <= xHoles; i++) {
        for (let j = 0; j <= zHoles; j++) {
          const x = (i - xHoles / 2) * threadGrid;
          const z = (j - zHoles / 2) * threadGrid;

          // Skip holes that would extend beyond plate boundaries with margin
          const halfWidth = width / 2;
          const halfDepth = depth / 2;
          const holeRadius = threadDia / 2;

          if (Math.abs(x) + holeRadius + edgeMargin > halfWidth) continue;
          if (Math.abs(z) + holeRadius + edgeMargin > halfDepth) continue;

          const threadHole = createThreadedHole(threadDia, threadDepth + 0.5, isThrough);
          const yOffset = isThrough ? 0 : (thickness - threadDepth) / 2;
          threadHole.position.set(x, yOffset, z);
          threadHole.updateMatrixWorld(true);

          const holeBrush = new Brush(threadHole);
          holeBrush.updateMatrixWorld();

          plateBrush = evaluator.evaluate(plateBrush, holeBrush, SUBTRACTION);
        }
      }

      // Subtract mounting holes with counterbore
      const mountingThreadDia = threadType === 'M5' ? 5.2 : threadType === 'M6' ? 6.2 : 8.2;
      const mountingBoreDia = mountingThreadDia * 2;
      const mountingBoreDepth = thickness > 9.8 ? thickness - 9.8 : 0;
      const mountingCount = getMountingHoleCount(width, depth);

      const mountingPositions = getMountingPositions(width, depth, mountingCount);

      mountingPositions.forEach(([x, z]) => {
        let mountingHole;
        if (mountingBoreDepth > 0) {
          mountingHole = createCounterbore(mountingThreadDia, mountingBoreDia, mountingBoreDepth, thickness + 0.5);
        } else {
          mountingHole = createThreadedHole(mountingThreadDia, thickness + 0.5, true);
        }
        mountingHole.position.set(x, 0, z);
        mountingHole.updateMatrixWorld(true);

        const holeBrush = new Brush(mountingHole);
        holeBrush.updateMatrixWorld();

        plateBrush = evaluator.evaluate(plateBrush, holeBrush, SUBTRACTION);
      });

      plateMesh = new THREE.Mesh(plateBrush.geometry, aluminumMaterial);
      plateMesh.castShadow = true;
      scene.add(plateMesh);

      updateInfo(width, depth, thickness);
    }

    function getMountingPositions(width, depth, count) {
      if (count === 2) return [[-50, 0], [50, 0]];
      if (count === 4) return [[-50, -50], [-50, 50], [50, -50], [50, 50]];
      if (count === 6) return [[-50, -100], [-50, 0], [-50, 100], [50, -100], [50, 0], [50, 100]];
      if (count === 12) return [
        [-100, -150], [-100, -50], [-100, 50], [-100, 150],
        [0, -150], [0, 150],
        [100, -150], [100, -50], [100, 50], [100, 150]
      ];
      return [[-50, -50], [-50, 50], [50, -50], [50, 50]];
    }
    
    function getMountingHoleCount(width, depth) {
      if (width === 100 && depth === 200) return 2;
      if (width === 200 && depth === 200) return 4;
      if (width === 200 && depth === 300) return 6;
      if (width === 300 && depth === 400) return 12;
      return 4;
    }
    
    function updateInfo(width, depth, thickness) {
      const threadType = document.getElementById('thread-type').value;
      const isThrough = thickness <= 9.8;
      const mountingCount = getMountingHoleCount(width, depth);
      const mountingDia = threadType === 'M5' ? 5.2 : threadType === 'M6' ? 6.2 : 8.2;
      
      document.getElementById('info-thread-depth').textContent = 
        isThrough ? `${thickness}mm (through)` : `${(thickness * 0.8).toFixed(1)}mm`;
      document.getElementById('info-through').textContent = isThrough ? 'Yes' : 'No';
      document.getElementById('info-mounting').textContent = mountingCount;
      document.getElementById('info-mounting-dia').textContent = `${mountingDia}mm`;
    }
    
    function updatePlate() {
      const size = document.getElementById('plate-size').value.split('x');
      const width = parseFloat(size[0]);
      const depth = parseFloat(size[1]);
      const thickness = parseFloat(document.getElementById('plate-thickness').value);
      createPlate(width, depth, thickness);
    }
    
    document.getElementById('plate-size').addEventListener('change', updatePlate);
    document.getElementById('plate-thickness').addEventListener('change', updatePlate);
    document.getElementById('thread-type').addEventListener('change', updatePlate);
    document.getElementById('thread-grid').addEventListener('input', updatePlate);
    document.getElementById('edge-margin').addEventListener('input', updatePlate);
    
    function onPointerDown(e) {
      isDragging = true;
      autoRotate = false;
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      previousMousePosition = { x: clientX, y: clientY };
      velocity = { x: 0, y: 0 };
    }
    
    function onPointerMove(e) {
      if (isDragging) {
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const deltaX = clientX - previousMousePosition.x;
        const deltaY = clientY - previousMousePosition.y;
        
        velocity.x = deltaX * 0.01;
        velocity.y = deltaY * 0.01;
        
        rotationY += velocity.x;
        rotationZ += velocity.y;
        rotationZ = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotationZ));
        
        previousMousePosition = { x: clientX, y: clientY };
      }
    }
    
    function onPointerUp() {
      isDragging = false;
    }
    
    canvas.addEventListener('mousedown', onPointerDown);
    canvas.addEventListener('mousemove', onPointerMove);
    canvas.addEventListener('mouseup', onPointerUp);
    canvas.addEventListener('touchstart', onPointerDown);
    canvas.addEventListener('touchmove', onPointerMove);
    canvas.addEventListener('touchend', onPointerUp);
    
    function animate() {
      requestAnimationFrame(animate);
      
      if (!isDragging) {
        velocity.x *= 0.95;
        velocity.y *= 0.95;
        
        if (Math.abs(velocity.x) > 0.001 || Math.abs(velocity.y) > 0.001) {
          rotationY += velocity.x;
          rotationZ += velocity.y;
          rotationZ = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotationZ));
        } else if (autoRotate) {
          rotationY += 0.005;
        }
      }
      
      if (plateMesh) {
        plateMesh.rotation.y = rotationY;
        plateMesh.rotation.z = rotationZ;
      }
      
      renderer.render(scene, camera);
    }
    
    window.addEventListener('resize', () => {
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);
    });
    
    createPlate(200, 200, 9.8);
    animate();
  </script>
</body>
</html>
